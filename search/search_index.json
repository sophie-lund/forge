{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#_1","title":"Forge","text":"A programming langauge I'm writing for run. :3   <p>For developers: check out getting started for more information on how to get started with Forge.</p>"},{"location":"for-developers/architecture/","title":"Architecture","text":""},{"location":"for-developers/architecture/#architecture","title":"Architecture","text":"<p>Warning</p> <p>This describes planned architecture that isn't fully built out yet. It's a work in progress. - Sophie (2025)</p>"},{"location":"for-developers/architecture/#birds-eye-view","title":"Bird's eye view","text":"<p>asdf</p>"},{"location":"for-developers/architecture/#code-map","title":"Code map","text":""},{"location":"for-developers/architecture/#cratesforge-core","title":"<code>crates/forge-core</code>","text":"<p>This is the core library where most of the Forge compiler is implemented. The command line interface and language server both use this library to provide functionality.</p>"},{"location":"for-developers/architecture/#cross-cutting-concerns","title":"Cross-cutting concerns","text":""},{"location":"for-developers/getting-started/","title":"Getting started","text":""},{"location":"for-developers/getting-started/#getting-started","title":"Getting started","text":"<p>You'll need to install these dependencies on your system to get started:</p> <ul> <li>Rust</li> <li>Material for MkDocs (only for editing this book)</li> </ul> <p>Run this command to run the automated tests:</p> <pre><code>cargo test\n</code></pre> <p>And to serve a development version of the book, run:</p> <pre><code>cd docs\nmkdocs serve\n</code></pre>"},{"location":"for-developers/concepts/abstract-syntax-tree/","title":"Abstract syntax tree","text":""},{"location":"for-developers/concepts/abstract-syntax-tree/#abstract-syntax-tree-ast","title":"Abstract Syntax Tree (AST)","text":"<p>The AST is implemented as a tree of structs that represent parsed Forge code. The structs are written by hand which has the advantage of quicker implementation and better optimization, but it also means that code consistency needs to be maintained manually. Make sure to follow these guidelines when adding new structs.</p>"},{"location":"for-developers/concepts/abstract-syntax-tree/#code-map","title":"Code map","text":"<p>All of the code is defined in <code>crates/forge-core/src/ast/*</code>. It's split up into files by concern:</p> <ul> <li><code>structs.rs</code>: Where the structs themselves are defined.</li> <li><code>traits.rs</code>: The traits that the structs must implement to provide shared functionality.</li> <li><code>impls.rs</code>: The implementations of the traits in <code>traits.rs</code> for the structs in <code>structs.rs</code>. This code can be hard to read and repetitive, so it's put in a separate file so keep the other two files more readable.</li> </ul>"},{"location":"for-developers/concepts/abstract-syntax-tree/#adding-a-new-ast-node-type","title":"Adding a new AST node type","text":"<p>This is an example struct definition in <code>structs.rs</code>:</p> <pre><code>#[derive(Debug, Clone, Serialize)]\npub struct ExprCall&lt;'sctx&gt; {\n    #[serde(rename = \"sourceRange\")]\n    pub source_range: Option&lt;SourceRange&lt;'sctx&gt;&gt;,\n\n    pub callee: Box&lt;Expr&lt;'sctx&gt;&gt;,\n\n    pub args: Vec&lt;Expr&lt;'sctx&gt;&gt;,\n}\n\nimpl&lt;'ctx&gt; IsNode&lt;'ctx&gt; for ExprCall&lt;'ctx&gt; {}\n</code></pre> <p>Let's go through it step by step.</p> <p>All of them must implement the <code>Debug</code>, <code>Clone</code>, and <code>Serialize</code> traits. These can be automatically derived:</p> <pre><code>#[derive(Debug, Clone, Serialize)]\n</code></pre> <p>Then the struct needs to contain some standard attributes. Right now the only one is <code>source_range</code>, but this may expand in the future:</p> <pre><code>#[serde(rename = \"sourceRange\")]\npub source_range: Option&lt;SourceRange&lt;'sctx&gt;&gt;,\n</code></pre> <p>Todo</p> <p>This page needs to be expanded.</p>"},{"location":"for-developers/concepts/abstract-syntax-tree/#adding-a-new-category-of-ast-nodes","title":"Adding a new category of AST nodes","text":""},{"location":"for-developers/concepts/lexing/","title":"Lexing","text":""},{"location":"for-developers/concepts/lexing/#lexing","title":"Lexing","text":"<p>The lexer is implemented by hand in order to operate on graphemes.</p> <p>Todo</p> <p>Expand this page.</p>"},{"location":"for-developers/concepts/messaging/","title":"Messaging","text":""},{"location":"for-developers/concepts/messaging/#messaging","title":"Messaging","text":"<p>Messaging is how the compiler communicates warnings and errors to the user. It's based around the <code>OutputMessage</code> trait which accepts messages from different parts of the compiler code. See its documentation for an example how to to use it.</p> <p>Todo</p> <p>Expand this page.</p>"},{"location":"for-developers/concepts/sourcing/","title":"Sourcing","text":""},{"location":"for-developers/concepts/sourcing/#sourcing","title":"Sourcing","text":"<p>Sourcing is how source code is loaded from various sources and read. It can be read from files on disk or strings in memory. Source code is also ephemeral - it may be edited by a developer at any time.</p>"},{"location":"for-developers/concepts/sourcing/#unicode-characters-and-column-numbers","title":"Unicode characters and column numbers","text":"<p>Column numbers are simple in ASCII because a symbol on screen is one byte. But with Unicode, one symbol on screen can be represented with many bytes. For example, this is a single symbol - try selecting it:</p> <p>\ufdfd</p> <p>This single symbol is made up of the following 3 bytes <code>ef b7 bd</code>, but still is treated as one single symbol by editors. Thus we should treat it as one column for error reporting.</p> <p>The Unicode standard uses the term extended grapheme clusters to refer to a single symbol on screen. In order to keep things simple, Forge treats source code as a sequence of extended grapheme clusters. When iterating over them, each cluster either takes up a single column or is a newline character.</p>"},{"location":"for-developers/concepts/sourcing/#terminology","title":"Terminology","text":"<ul> <li>Source - one file or string that contains source code.</li> <li>Grapheme - the source code calls extended grapheme clusters \"graphemes\" for brevity, much like the <code>unicode_segmentation</code> crate.</li> <li>Source location - a reference to a specific grapheme in source code containing the byte offset, line number, and column number.</li> <li>Source range - a span of source code between two source locations, implemented as one location and a length in bytes.</li> </ul>"},{"location":"for-developers/concepts/sourcing/#lookahead-and-lexing","title":"Lookahead and lexing","text":"<p>Forge's lexer is implemented by hand, so to keep things simple source code is read one grapheme at a time but with a one-grapheme lookahead. This means that you can both read and peek the next grapheme.</p>"}]}